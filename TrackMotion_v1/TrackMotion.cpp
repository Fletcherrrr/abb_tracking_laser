/////////////////////////////////////////////////////////////////////////
// Inherited from the Sample using Google protocol buffers C++ provided by ABB
// Historical Version:
// 2020.01.16 Combine the Spiral and Eclipse tracking, Multi-thread, 3D and 6D into one single project.
// 2020.01.09 Useable version that can be used for tracking. Single Thread.
// 2019.12.23 adding Eigen lib into the program
// 2019.12.18, 2019.12.16.1
// Author: Fletcher
// Protobuf version: 3.2.0
// 

/*MANUAL*/
//All the angles are expressed in EULER XYZ order!



#include "egm.h"
#include "stdafx.h"
#include <Eigen/Dense>
#include <WinSock2.h>
#include <iostream>
#include <fstream>
#include "conio.h"
#include "Geometrymodel.h"
#include "CoordGen.h"
#include "Axis.h"
#include "egm.pb.h" // generated by Google protoc.exe
#include "Use_Abb_Beckhoff.h"
#include <thread>
#include "OriGen.h"
#pragma comment(lib, "Ws2_32.lib")      // socket lib
//#pragma comment(lib, "libprotobuf.lib") // protobuf lib

using namespace std;



// Protobuf-C++ is supported by Google and no other third party libraries needed for the protobuf part. 
// It can be a bit tricky to build the Google tools in Windows but here is a guide on how to build 
// protobuf for Windows (http://eli.thegreenplace.net/2011/03/04/building-protobuf-examples-on-windows-with-msvc).
//
// When you have built libprotobuf.lib and protoc.exe:
//	 Run Google protoc to generate access classes, protoc --cpp_out=. egm.proto
//	 Create a win32 console application
//	 Add protobuf source as include directory
//	 Add the generated egm.pb.cc to the project (exclude the file from precompile headers)
//	 Copy the file below
//	 Compile and run
//
//
// Copyright (c) 2014, ABB
// All rights reserved.

/**********************/
/*  Global Variables  */
/**********************/
// 3D or 6D?
#define THREEDIM 0
#define SIXDIM 1
int g_Dim = 1;
// Parameters for GetQuaternionAndOffset()
#define XYZ 0
#define ZXZ 1
/****************************************/
/*  Parameters for the laser standard   */
/****************************************/

#define CONTROLLER_TYPE		PMC007C6S//控制器类型

#define AXIS1_NODEID		5//Axis1轴节点ID Modified 20191227
#define AXIS2_NODEID		1//Axis2轴节点ID
#define AXIS3_NODEID		2//Axis3轴节点ID
#define AXIS4_NODEID		3//Axis4轴节点ID
#define AXIS5_NODEID		4//Axis4轴节点ID
#define AXIS6_NODEID		6//Axis4轴节点ID

//4000 脉冲一圈
#define MICROSTEP			32//细分数
#define CURRENT				3000//电流 最大电流3A
#define CURRENT2			4000//竖直轴 最大电流4A
#define MOVING_SPEED		2000 //普通运动速度，有符号吗？
#define FINDORG_SPEED		-4000 //找零速度,有符号，-表示反向
#define FINDORG_STEPNUM		90000 //找零最大步数
#define ORG_EXT				EXT_STOP1 //原点对应的外部停止
#define MAX_PVT_NUM			400 //最大PVT点数
#define EXT_TRIG_MODE		EXT_TRIG_FALLING //触发模式


/*********************程序内部定义*********************/
#define POSMODE 0
#define PVT3MODE 1

#define AXIS1	0     //Modified 20191227
#define AXIS2	1
#define AXIS3	2
#define AXIS4	3
#define AXIS5	4
#define AXIS6	5

#define AXIS_MAX			6//最大轴数 modified 20191227
#define OPEN				0//开环控制
#define CLOSE				1//闭环控制

#if (ORG_EXT == EXT_STOP1)
#define PORT_EXT			GPIO_EXT1
#define STATUS_EXT			CS_EXT1
#elif (ORG_EXT == EXT_STOP2)
#define PORT_EXT			GPIO_EXT2
#define STATUS_EXT			CS_EXT2
#elif (ORG_EXT == EXT_STOP3)
#define PORT_EXT			GPIO_EXT3
#define STATUS_EXT			CS_EXT3
#endif

#if (CONTROLLER_TYPE == PMC007C3SE) || (CONTROLLER_TYPE == PMC007C6SE)
#define CTRL_T		CLOSE
#else
#define CTRL_T		OPEN	
#endif

#define PI 3.14159265
#define RAD 200.0
#define PTNUM 18  //PVT number per writting
#define PTNUMINI 80  //PVT number first writting
#define PVT3LOWER 40
#define PVT3UPPER 80
/*********************数据结构定义*********************/
//单轴要运动到的目标位置点
typedef struct
{
	int nAxisPosition[6]; //各个轴的6个开始位置点, modified on 20191227 (一共6轴)
}AXIS_POSITION;

/************************变量定义*********************/
/*1轴*/
CAxis g_Axis1(AXIS1_NODEID);
/*2轴*/
CAxis g_Axis2(AXIS2_NODEID);
/*3轴*/
CAxis g_Axis3(AXIS3_NODEID);
/*4轴*/
CAxis g_Axis4(AXIS4_NODEID);
/*4轴*/
CAxis g_Axis5(AXIS5_NODEID);
/*4轴*/
CAxis g_Axis6(AXIS6_NODEID);
/*所有轴*/
CAxis *g_pAllAxis[AXIS_MAX] = {&g_Axis1,&g_Axis2,&g_Axis3,&g_Axis4,&g_Axis5,&g_Axis6};

/********************关键点的定义**********************/
//绝对位置，用脉冲数表示
int g_AxesCenterPosition[6]=
{471.5*4000.0/60,474.2*4000.0/60,471.5*4000.0/60,474.2*4000.0/60,125.0*4000.0/10,128.8*4000.0/10};  //zero point

int g_AxesStartPosition[6]=
{0.0*4000/60,-RAD*4000/60,0.0*4000/60,RAD*4000/60,0.0*4000/10,0.0*4000/10};  //ralative
//20191227

/****************************************/
/*         Callback functions           */
/****************************************/
PCANResult __stdcall SlaveChangeCallback(DWORD dwNodeID,BOOL bOnline)
{
	if(TRUE == bOnline){		
		//节点上线
		for(int i=0;i<AXIS_MAX;i++){
			if(g_pAllAxis[i]->m_dwNodeID == dwNodeID){
				g_pAllAxis[i]->m_bSlaveOnline = TRUE;
				::SetEvent(g_pAllAxis[i]->m_hSlaveOnline);
			}
		}
	}else{
		//节点下线
		for(int i=0;i<AXIS_MAX;i++){
			if(g_pAllAxis[i]->m_dwNodeID == dwNodeID){
				g_pAllAxis[i]->m_bSlaveOnline = FALSE;
				::ResetEvent(g_pAllAxis[i]->m_hSlaveOnline);
			}
		}
	}
	return PCAN_SUCCESS;
}
PCANResult __stdcall TraceCallback(char* szTrace)
{
	//printf("%s",szTrace);  //把Can总线的每一步都打印出来，已注释掉
	return PCAN_SUCCESS;
}
PCANResult __stdcall TPDOCallback(DWORD dwNodeID,DWORD dwTPDOChannel,BYTE* pTPDOData,DWORD dwLen)
{
	//PMC007xx默认TPDO映射第一通道第二个字节为控制状态
	if(TPDO_CH1 == dwTPDOChannel){
		for(int i=0;i<AXIS_MAX;i++){
			if(g_pAllAxis[i]->m_dwNodeID == dwNodeID){
				g_pAllAxis[i]->UpdateControlStatus(pTPDOData[1]);				
			}
		}	
	}
	return PCAN_SUCCESS;
}

/****************************************/
/*         Thread functions             */
/****************************************/
int TrdWritePVT(CoordGen* laserFrame, CAxis* g_pAllAxis[], int* nTimeElapseLaser, int nTimeInterval, BOOL* complete){
	int nPosition;
	int nVelocity;
	PCANResult result;
	//写当前PTNUM个PVT数据
	for (int j=0; j<PTNUM; j++){

		laserFrame->PointGen(75.0);
		//printf("yeah!\n\n");
		laserFrame->currentTime = ((double)(*nTimeElapseLaser+nTimeInterval))/1000.0; //ms to second

		*nTimeElapseLaser = *nTimeElapseLaser+nTimeInterval;  //Update the Elapsed Time of the laser
		printf("Laser time is %d ms!",*nTimeElapseLaser);
		//nSeqNoLaser = nSeqNoLaser+1; //Update the SeqNo of the laser
		//printf("TimeElapseLaser = %d ms\n",nTimeElapseLaser);
		for (int i=0; i<AXIS_MAX; i++){
			switch (i)
			{
				//Axis1
			case 0:
				nPosition = (int)((6400.0/60.0)*laserFrame->nPosition.y);
				nVelocity = (int)((6400.0/60.0)*laserFrame->nVelocity.v_y);         
				//printf("Axis1:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis2
			case 1:
				nPosition = (int)((6400.0/60.0)*(-laserFrame->nPosition.x));
				nVelocity = (int)((6400.0/60.0)*(-laserFrame->nVelocity.v_x));         
				//printf("Axis2:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);		
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis3
			case 2:
				nPosition = (int)((6400.0/60.0)*(-laserFrame->nPosition.y));
				nVelocity = (int)((6400.0/60.0)*(-laserFrame->nVelocity.v_y));         
				//printf("Axis3:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis4
			case 3:
				nPosition = (int)((6400.0/60.0)*laserFrame->nPosition.x);
				nVelocity = (int)((6400.0/60.0)*laserFrame->nVelocity.v_x);         
				//printf("Axis4:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis5
			case 4:
				nPosition = (int)((6400.0/10.0)*laserFrame->nPosition.z);
				nVelocity = (int)((6400.0/10.0)*laserFrame->nVelocity.v_z);         
				//printf("Axis5:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis6
			case 5:
				nPosition = (int)((6400.0/10.0)*laserFrame->nPosition.z);
				nVelocity = (int)((6400.0/10.0)*laserFrame->nVelocity.v_z);         
				//printf("Axis6:p=%d,v=%d,t=%d\n",nPosition,nVelocity,nTimeInterval);	
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
			default:
				break;
			}
		}
	}
	*complete = TRUE;
	return 0;
}

int _tmain(int argc, _TCHAR* argv[])
{
	int currentMotorPos[6];  // Current motor pos when switch to PVT mode


	/***************************************************************************
	/* Part1: Laser Initialization
	/* Version: 2020.01.01
	/***************************************************************************

	/*   Initialize the laser standard   */
	PCANResult result = PCAN_SUCCESS;	
	DWORD dwGPIOValue = 0;
	DWORD dwGroupID = 1;
	//int nMaxPVTNum = 0;
	result = CAxis::Init(CX_CANALYST_II, CONTROLLER_TYPE, TRACE_LEVEL1);//动态库初始化
	if(PCAN_SUCCESS != result)
	{
		printf("PCAN_Init fail!\n");
		return 0;
	}
	CAxis::SetEventCallback(SlaveChangeCallback,TraceCallback,TPDOCallback); //回调函数初始化
	//CAxis::SetTCPClient("192.168.0.178",4001);  //以太网转CAN适配器需要添加此设置
	//CAxis::SetSerialPort(1,9600);  //串口转CAN适配器需要添加此设置
	result = CAxis::OpenPort(BR_125KBPS);//打开适配器端口,波特率125K
	if(PCAN_SUCCESS != result)  //打开适配器端口
	{
		printf("PCAN_OpenPort fail!\n");
		return 0;
	}
	//等待所有轴节点上线
	for(int i=0;i<AXIS_MAX;i++){
		::WaitForSingleObject(g_pAllAxis[i]->m_hSlaveOnline,INFINITE);
	}	

	//设置基本参数
	for(int i=0;i<AXIS_MAX;i++){
		//设置细分
		result = g_pAllAxis[i]->SetMicroStep(MICROSTEP);
		if (PCAN_SUCCESS != result)
		{
			printf("SetMicroStep fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//设置电流
		if (i<4){
			result = g_pAllAxis[i]->SetPeakCurrent(CURRENT);
			if (PCAN_SUCCESS != result){
				printf("SetPeakCurrent fail!\n");
				CAxis::ClosePort();
				return 0;
			}
		}
		else{
			result = g_pAllAxis[i]->SetPeakCurrent(CURRENT2);
			if (PCAN_SUCCESS != result){
				printf("SetPeakCurrent fail!\n");
				CAxis::ClosePort();
				return 0;
			}
		}

		//设置工作模式为位置模式
		result = g_pAllAxis[i]->SetWorkMode(WM_POS); // In PVT mode, it will be WM_PVT
		if (PCAN_SUCCESS != result)
		{
			printf("SetWorkMode fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//设置加速度5
		result = g_pAllAxis[i]->SetAccel(5);
		if (PCAN_SUCCESS != result)
		{
			printf("SetAccel fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//设置减速度5
		result = g_pAllAxis[i]->SetDecel(5);
		if (PCAN_SUCCESS != result)
		{
			printf("SetDecel fail!\n");
			CAxis::ClosePort();
			return 0;
		}
	}

	/*Homing the laser standard*/
	//Only homing along the negative direction
	for(int i=0;i<AXIS_MAX;i++){
		result = g_pAllAxis[i]->GetGPIOValue(&dwGPIOValue); //获取GPIO值
		if (PCAN_SUCCESS != result)
		{
			printf("GetGPIOValue fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		if(dwGPIOValue&(1<<PORT_EXT)){ //未在原点上才启动步进
			//设置下降沿触发
			result = g_pAllAxis[i]->SetExtStopTrigger(EXT_TRIG_MODE<<ORG_EXT);
			if (PCAN_SUCCESS != result)
			{
				printf("SetExtStopTrigger fail!\n");
				CAxis::ClosePort();
				return 0;
			}
			//打开外部紧急停止
			result = g_pAllAxis[i]->SetExtStopEnable(1<<ORG_EXT);
			if (PCAN_SUCCESS != result)
			{
				printf("SetExtStopEnable fail!\n");
				CAxis::ClosePort();
				return 0;
			}
			result = g_pAllAxis[i]->ClearExtStopFlag(1 << STATUS_EXT); //清除外部停止
			if (PCAN_SUCCESS != result)
			{
				printf("ClearExtStopFlag fail!\n");
				CAxis::ClosePort();
				return 0;
			}
			//设置找零速度
			if (i<4){
				result = g_pAllAxis[i]->SetMaxSpeed(FINDORG_SPEED);
				if (PCAN_SUCCESS != result)
				{
					printf("SetMaxSpeed fail!\n");
					CAxis::ClosePort();
					return 0;
				}
			}else{
				result = g_pAllAxis[i]->SetMaxSpeed(FINDORG_SPEED-2000);
				if (PCAN_SUCCESS != result)
				{
					printf("SetMaxSpeed fail!\n");
					CAxis::ClosePort();
					return 0;
				}
			}
			//启动步进
			result = g_pAllAxis[i]->StartRelStep(FINDORG_STEPNUM);   //第 i 个轴开始运动，用的指针数组
			if (PCAN_SUCCESS != result)
			{
				printf("StartAbsStep fail!\n");
				CAxis::ClosePort();
				return 0;
			}
		}
	}

	//等待步进完成&清外部停止
	for(int i=0;i<AXIS_MAX;i++){
		::WaitForSingleObject(g_pAllAxis[i]->m_hSlaveIdle,INFINITE); 
		Sleep(50);
		result = g_pAllAxis[i]->ClearExtStopFlag(1 << STATUS_EXT); //清除外部停止
		if (PCAN_SUCCESS != result)
		{
			printf("ClearExtStopFlag fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		result = g_pAllAxis[i]->SetMotorPos(0); //马达位置清零
		if (PCAN_SUCCESS != result)
		{
			printf("SetMotorPos fail!\n");
			CAxis::ClosePort();
			return 0;
		}
	}	

	/*Move to the center position, and set it as zero point*/
	//isNotBusy?
	while(1){
		if (!(g_pAllAxis[0]->m_bBusy || g_pAllAxis[1]->m_bBusy || g_pAllAxis[2]->m_bBusy || g_pAllAxis[3]->m_bBusy || g_pAllAxis[4]->m_bBusy || g_pAllAxis[5]->m_bBusy)){
			printf("All the axes are not busy!\n");
			Sleep(100);
			break;
		}
	}
	//If not busy, move.
	for(int i=0;i<AXIS_MAX;i++){
		//设置速度
		result = g_pAllAxis[i]->SetMaxSpeed(MOVING_SPEED);  //不改速度符号
		if (PCAN_SUCCESS != result)
		{
			printf("SetMaxSpeed fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//启动步进
		result = g_pAllAxis[i]->StartAbsStep(g_AxesCenterPosition[i]);   //第 i 个轴开始运动，i=0->1轴，以此类推
		if (PCAN_SUCCESS != result)
		{
			printf("StartAbsStep fail!\n");
			CAxis::ClosePort();
			return 0;
		}

	}

	/*Move to the start position*/
	//isNotBusy?
	while(1){
		if (!(g_pAllAxis[0]->m_bBusy || g_pAllAxis[1]->m_bBusy || g_pAllAxis[2]->m_bBusy || g_pAllAxis[3]->m_bBusy || g_pAllAxis[4]->m_bBusy || g_pAllAxis[5]->m_bBusy)){
			printf("All the axes are not busy!\n");
			Sleep(100);
			break;
		}
	}
	//If not busy, move.
	for(int i=0;i<AXIS_MAX;i++){
		result = g_pAllAxis[i]->SetMotorPos(0); //马达位置清零
		if (PCAN_SUCCESS != result)
		{
			printf("SetMotorPos fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//设置速度
		result = g_pAllAxis[i]->SetMaxSpeed(MOVING_SPEED);  //不改速度符号
		if (PCAN_SUCCESS != result)
		{
			printf("SetMaxSpeed fail!\n");
			CAxis::ClosePort();
			return 0;
		}
		//启动步进
		result = g_pAllAxis[i]->StartAbsStep(g_AxesStartPosition[i]);   //第 i 个轴开始运动，i=0->1轴，以此类推
		printf("The %dth axis is moving to %d", i+1, g_AxesStartPosition[i]);
		if (PCAN_SUCCESS != result)
		{
			printf("StartAbsStep fail!\n");
			CAxis::ClosePort();
			return 0;
		}
	}



	/*PVT3 setting*/
	//isNotBusy?
	while(1){
		if (!(g_pAllAxis[0]->m_bBusy || g_pAllAxis[1]->m_bBusy || g_pAllAxis[2]->m_bBusy || g_pAllAxis[3]->m_bBusy || g_pAllAxis[4]->m_bBusy || g_pAllAxis[5]->m_bBusy)){
			printf("All the axes are not busy!\n");
			Sleep(100);
			break;
		}
	}
	//Parameters setting
	for(int i=0;i<AXIS_MAX;i++){

		//获取当前位置
		result = g_pAllAxis[i]->GetMotorPos(&currentMotorPos[i]);   //第 i 个轴开始运动，i=0->1轴，以此类推
		printf("The position of the %dth axis is %d", i+1, currentMotorPos[i]);
		if (PCAN_SUCCESS != result)
		{
			printf("StartAbsStep fail!\n");
			CAxis::ClosePort();
			return 0;
		}

		//设置所有轴的工作模式为PVT模式
		result = g_pAllAxis[i]->SetWorkMode(WM_PVT);
		if (PCAN_SUCCESS != result)
		{
			printf("SetWorkMode fail!\n");
			return result;
		}
		//设置组ID
		result = g_pAllAxis[i]->SetGroupID(dwGroupID); 
		if (PCAN_SUCCESS != result)
		{
			printf("SetGroupID fail!\n");	
			return result;
		}
		//设置最大PVT点数(最大FIFO深度)400
		result = g_pAllAxis[i]->SetMaxPVTNum(200);
		if (PCAN_SUCCESS != result)
		{
			printf("SetMaxPVTNum fail!\n");
			return result;
		}
		//设置PVT模式3 无限FIFO模式
		result = g_pAllAxis[i]->SetPVTMode(PVT_MODE3);
		if (PCAN_SUCCESS != result)
		{
			printf("SetPVTMode fail!\n");		
			return result;
		}	
		//设置PVT模式3参数,fifo长度小于40或大于PTNUM时通知
		result = g_pAllAxis[i]->SetPVT3Para(PVT3LOWER,PVT3UPPER);
		if (PCAN_SUCCESS != result)
		{
			printf("SetPVT3Para fail!\n");		
			return result;
		}
		//设置马达位置
		result = g_pAllAxis[i]->SetMotorPos(currentMotorPos[i]); //马达位置设置为上次走到的马达位置
		if (PCAN_SUCCESS != result)
		{
			printf("SetMotorPos fail!\n");
			CAxis::ClosePort();
			return 0;
		}
	}


	// Now the parameters of Laser standard have be set.
	// And the laser has been moved to its initial position.
	// Then the EGM of the robot should be started.

	/*******************************************************************************************
	/* Part2: EGM Initialization
	/* Version: 2020.01.01
	/*******************************************************************************************
	/*instantiaion the class of Geometrymodel*/
	Geometrymodel ROB1;

	/*instantiaion the class of EGM*/
	int nRobmsg; //Trouble shooting
	Egm EGM1("192.168.125.204",6510); // Establish an Egm connection through Udp.

	/*instantiaion the class of Use_Abb_Beckhoff*/
	/*Ask the user to start the Robot*/
	printf("Please start BECKHOFF and THEN PRESS ANY KEY!\n");
	_getch();

	Use_Abb_Beckhoff ABBBECKHOFF1;
	//Initialize the robot	
	//ABBBECKHOFF1.clearAll();  //No need to clearup because it will end the UDP sever    
	ABBBECKHOFF1.iniAll();     //initialize socket, workspace etc.
	ABBBECKHOFF1.connectServer(ABBBECKHOFF1.BECKHOFF, "192.168.125.205", 7001); // Connect Beckhoff, and "127.0.0.1" is for local


	/*instantiaion the class of CoordGen*/
	CoordGen laserFrame(0.0,0.0,0.0,RAD,0.0,0.0);
	//Set the trace (Spiral) of the laser. units: mm rad second
	laserFrame.w0 = 3.0/360.0*2.0*PI;  //angular velocity of the spiral: rad/s
	laserFrame.alpha0 = 3.0/360.0*2.0*PI;  //angular acceleration of the spiral: rad/s^2
	laserFrame.v0 = 0.5;  //velocity of the spiral in vertical direction: mm/s
	laserFrame.a0 = 0.5;   //acceleration of the spiral in vertical direction: mm/s^2
	laserFrame.tmax = 200.0;   //max time of the tracing exclude the deceleration time.
	laserFrame.currentTime = 0.0;  //initialize the current time

	//Instantiaiaion of the OriGen
	OriGen ROB1ORI(0.0175, laserFrame.w0*12.0);//1: Amplitude 1 deg = 0.0175 rad; 2:angularspeed = w rad/s Here w is 1/period
	// Here, the same w0 as the laser frame is used

	//More Parameters of the EGM
	int nTimeInterval = 60;  //插补周期60 ms
	int nPlannedTimeRob = 0;   //Time of the next loop of the Rob
	int nTimeElapseRob = 0;	//Elapsed time	of the ROb
	int nTimeElapseLaser = 0; //Elapsed time of the LAser

	int nSeqNoRob = 0;    //Sequence number sent from the ROB

	int nSeqNoLaser = 0;   //Number if points has been sent to the Laser axes.
	int nPosition = 0;    //Position to be sent to Laser
	int nVelocity = 0;    //Velocity to be sent to Laser
	BOOL bStartStep = FALSE;
	BOOL bRobStart = FALSE;
	BOOL hasTrdWritting = FALSE;  //has written PVT though thread at least once
	BOOL tJoinable = FALSE;
	BOOL bWritePVTComplete = TRUE; //Since multithread is used, a sign is needed to detect whether the writing is complete.

	std::thread ptWritePVT[1];  //Define a thread for writting PVT

	DWORD dwStartTime = 0;
	DWORD dwEndTime = 0;

	/*Ask the user to start the Robot*/
	printf("Please PRESS ANY KEY and then START the robot!\n");

	_getch();
	Sleep(20);
	//先写PTNUM个PVT数据，这样在第一个循环里就可以startpvt
	for (int j=0; j<PTNUMINI; j++){

		laserFrame.PointGen(75.0);
		laserFrame.currentTime = ((double)(nTimeElapseLaser+nTimeInterval))/1000.0; //ms to second
		nTimeElapseLaser = nTimeElapseLaser+nTimeInterval;  //Update the Elapsed Time of the laser
		nSeqNoLaser = nSeqNoLaser+1; //Update the SeqNo of the laser
		//printf("TimeElapseLaser = %d ms\n",nTimeElapseLaser);
		for (int i=0; i<AXIS_MAX; i++){
			switch (i)
			{
				//Axis1
			case 0:
				nPosition = (int)((6400.0/60.0)*laserFrame.nPosition.y);
				nVelocity = (int)((6400.0/60.0)*laserFrame.nVelocity.v_y);         
				//printf("Axis1:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis2
			case 1:
				nPosition = (int)((6400.0/60.0)*(-laserFrame.nPosition.x));
				nVelocity = (int)((6400.0/60.0)*(-laserFrame.nVelocity.v_x));         
				//printf("Axis2:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);		
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis3
			case 2:
				nPosition = (int)((6400.0/60.0)*(-laserFrame.nPosition.y));
				nVelocity = (int)((6400.0/60.0)*(-laserFrame.nVelocity.v_y));         
				//printf("Axis3:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis4
			case 3:
				nPosition = (int)((6400.0/60.0)*laserFrame.nPosition.x);
				nVelocity = (int)((6400.0/60.0)*laserFrame.nVelocity.v_x);         
				//printf("Axis4:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis5
			case 4:
				nPosition = (int)((6400.0/10.0)*laserFrame.nPosition.z);
				nVelocity = (int)((6400.0/10.0)*laserFrame.nVelocity.v_z);         
				//printf("Axis5:p=%d,v=%d,t=%d ",nPosition,nVelocity,nTimeInterval);			
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
				//Axis6
			case 5:
				nPosition = (int)((6400.0/10.0)*laserFrame.nPosition.z);
				nVelocity = (int)((6400.0/10.0)*laserFrame.nVelocity.v_z);         
				//printf("Axis6:p=%d,v=%d,t=%d\n",nPosition,nVelocity,nTimeInterval);	
				result = g_pAllAxis[i]->WritePVT(nPosition,nVelocity,nTimeInterval);
				if (PCAN_SUCCESS != result)
				{
					printf("WritePVT fail!\n");		
					return result;
				}
				break;
			default:
				break;
			}
		}
	}


	while(1) //Start loop
	{

		//Start fetching messages from the robot//
		//If there is no msg, it means that the robot is not ready, wait.
		nRobmsg = EGM1.FetchRobotMessage();    // receive message from robot
		if (nRobmsg < 0)
		{
			//printf("Error receive message\n");
			continue;  // If there is no messsage, skip the current loop and move to the next loop.
		}
		bRobStart = TRUE; //If received the first message from the robot. It can be recoginzed that the robot is starting the EGM.


		//If there are msgs, means that the rob is ready. Let's Rock'in Roll!//
		//3 Steps:
		//1. Get the seqNo, so that the current time is obtained.
		//2. Calculate the current orientaion of the ROB and the current position of the laser.
		//3. Respectively send the coordinates to the ROB and the laser standard.

		//Calculate current time and Planned time, UNIT: ms!
		nSeqNoRob= EGM1.nSeqNoRob; //tHEORTICALLY, it is 200 smaller than nSeqNoLaser at the first loop
		nTimeElapseRob = EGM1.nSeqNoRob*nTimeInterval;
		nPlannedTimeRob = nTimeElapseRob+nTimeInterval;
		printf("nSeqNoRob is %d, Time elapsed is %d\n",nSeqNoRob, nTimeElapseRob);
		//先从beckhoff那里取值
		// Following 3 sentances are:
		//(1)Get string data from beckhoff;
		//(2)Parse the string data to integer;
		//(3)Transform int data to double (mm or deg).

		ABBBECKHOFF1.gettedData = ABBBECKHOFF1.getData();
		ABBBECKHOFF1.beckhoffDataNum = ABBBECKHOFF1.parseBeckhoffData(ABBBECKHOFF1.gettedData, ABBBECKHOFF1.beckhoffData); //Parse the data to array, save to beckhoffData.
		ABBBECKHOFF1.beckhoffDataDoubleNum = ABBBECKHOFF1.dataInt2Double(ABBBECKHOFF1.beckhoffData, ABBBECKHOFF1.beckhoffDataDouble); //Transfer the int data in array to the double ones.

		//计算位姿
		//Set PSD value

		ROB1.psd[0].value = ABBBECKHOFF1.beckhoffDataDouble[16];
		ROB1.psd[1].value = ABBBECKHOFF1.beckhoffDataDouble[17];
		ROB1.psd[2].value = ABBBECKHOFF1.beckhoffDataDouble[18];
		ROB1.psd[3].value = ABBBECKHOFF1.beckhoffDataDouble[19];
		ROB1.psd[4].value = ABBBECKHOFF1.beckhoffDataDouble[20];
		ROB1.psd[5].value = ABBBECKHOFF1.beckhoffDataDouble[21];
		ROB1.psd[6].value = ABBBECKHOFF1.beckhoffDataDouble[22];
		ROB1.psd[7].value = ABBBECKHOFF1.beckhoffDataDouble[23];
		ROB1.psd[8].value = ABBBECKHOFF1.beckhoffDataDouble[24];
		ROB1.psd[9].value = ABBBECKHOFF1.beckhoffDataDouble[25];
		ROB1.psd[10].value = ABBBECKHOFF1.beckhoffDataDouble[26];
		ROB1.psd[11].value = ABBBECKHOFF1.beckhoffDataDouble[27];

		ROB1.PSDTransform();// PSD Transform

		//Set Target value 根据当前的机器人位置计算姿态！这样可以保证轮廓误差
		if (g_Dim == THREEDIM){
			ROB1.qTinL.dtheta_x = 1.0/57.1;
			ROB1.qTinL.dtheta_y = 0.0;
			ROB1.qTinL.dtheta_z = 0.0;
		}else
		{
			ROB1ORI.SetTime(nPlannedTimeRob/1000.0);  //Input the time
			ROB1ORI.GetAngle(0.0175);  // double tilt angle speed
			//Here, for convenience, qTinL.ori is expressed by ZXZ euler angle or XYZ euler angle.
			//Please specify it in the following function: GetQuaternionAndOffset(int);
			ROB1.qTinL.dtheta_x = ROB1ORI.xAngle;  
			ROB1.qTinL.dtheta_y = ROB1ORI.yAngle;
			ROB1.qTinL.dtheta_z = ROB1ORI.zAngle;

		}

		//Start calculation
		ROB1.Iteration(ROB1.qRinL);
		ROB1.GetQuaternionAndOffset(ZXZ);
		//printf("The pose of the Target in the CS of Rigid is [%f mm, %f mm, %f mm, %f, %f, %f, %f]",ROB1.qTinR.d_x,ROB1.qTinR.d_y,ROB1.qTinR.d_z,ROB1.qTinR.q1,ROB1.qTinR.q2,ROB1.qTinR.q3,ROB1.qTinR.q4);

		//把位姿send to EGM
		EGM1.posePlanned.pos.x = ROB1.qTinR.d_x;
		EGM1.posePlanned.pos.y = ROB1.qTinR.d_y;
		EGM1.posePlanned.pos.z = ROB1.qTinR.d_z;
		EGM1.posePlanned.ori.q1 = ROB1.qTinR.q1;
		EGM1.posePlanned.ori.q2 = ROB1.qTinR.q2;
		EGM1.posePlanned.ori.q3 = ROB1.qTinR.q3;
		EGM1.posePlanned.ori.q4 = ROB1.qTinR.q4;
		//printf("planned to thetaZ=%f degree, thetaX=%f degree", ROB1ORI.zAngle*57.1,ROB1ORI.xAngle*57.1);
		// create and send a sensor message
		EGM1.CreateAndSendSensorMessage();


		//当fifo到达一定数据时（第1个循环）开始pvt步进,正式运行的时候这一段最好放在前面
		while(TRUE == ((bRobStart) && ((g_pAllAxis[0]->m_bPVT3High) || (g_pAllAxis[1]->m_bPVT3High) || (g_pAllAxis[2]->m_bPVT3High) || (g_pAllAxis[3]->m_bPVT3High) || (g_pAllAxis[4]->m_bPVT3High) || (g_pAllAxis[5]->m_bPVT3High)))){	
			if(FALSE == bStartStep){		
				//启动PVT步进(扩展NMT广播指令)
				printf("StartPVT!");
				result = CAxis::StartPVTStep(dwGroupID);
				if (PCAN_SUCCESS != result)
				{
					printf("StartPVTStep fail!\n");	
					return result;
				}
				bStartStep = TRUE;
			}
			//Sleep(10);
		}

		//fifo已经到下限时,计算速度点发送
		if (!hasTrdWritting){// The first time of writting PVT
			if(TRUE ==((g_pAllAxis[0]->m_bPVT3Low) || (g_pAllAxis[1]->m_bPVT3Low) || (g_pAllAxis[2]->m_bPVT3Low) || (g_pAllAxis[3]->m_bPVT3Low) || (g_pAllAxis[4]->m_bPVT3Low) || (g_pAllAxis[5]->m_bPVT3Low))){
				printf("FIFO low threshold!\n");
				if (bWritePVTComplete){
					printf("Write PVT Complete first time!\n\n");
					bWritePVTComplete = FALSE;
					//Start the Thread
					ptWritePVT[0] = std::thread(TrdWritePVT, &laserFrame, g_pAllAxis, &nTimeElapseLaser, nTimeInterval, &bWritePVTComplete);
					hasTrdWritting = TRUE;
					//tWritePVT.detach();
				}
			}
		}
		else{ //The 2nd 3rd...time to write PVT
			if(TRUE ==((g_pAllAxis[0]->m_bPVT3Low) || (g_pAllAxis[1]->m_bPVT3Low) || (g_pAllAxis[2]->m_bPVT3Low) || (g_pAllAxis[3]->m_bPVT3Low) || (g_pAllAxis[4]->m_bPVT3Low) || (g_pAllAxis[5]->m_bPVT3Low))){
				printf("FIFO low threshold!\n");
				//Before start the Thread, if the last thread has been done?
				if (bWritePVTComplete && ptWritePVT->joinable()){
					printf("Write PVT Complete and joinable!\n\n");
					bWritePVTComplete = FALSE;
					ptWritePVT->join();
					//Start a new thread
					ptWritePVT[0] = std::thread(TrdWritePVT, &laserFrame, g_pAllAxis, &nTimeElapseLaser, nTimeInterval, &bWritePVTComplete);
					//printf("Write PVT Start!\n");
					//tWritePVT.detach();
				}
			}
		}

		//If the max time has been reached
		if(nTimeElapseLaser/1000-laserFrame.tmax >= 50){
			break;  //Stop sending points
		}

	}

	printf("Program End!");
	_getch();
	return 0;
}